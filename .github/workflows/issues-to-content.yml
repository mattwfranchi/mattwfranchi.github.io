name: Convert Issues to Content

on:
  issues:
    types: [labeled, opened]

jobs:
  convert-issue:
    if: contains(github.event.issue.labels.*.name, 'snip') || contains(github.event.issue.labels.*.name, 'playlist') || contains(github.event.issue.labels.*.name, 'album')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Convert Issue to Content
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Get issue details
            const issue = context.payload.issue;
            let title = issue.title;
            const body = issue.body || '';
            const labels = issue.labels.map(label => label.name);
            
            // Clean up title (remove prefixes like [SNIP], [PLAYLIST], [ALBUM])
            title = title.replace(/^\[.*?\]\s*/, '').trim();
            
            // Determine content type
            let contentType = null;
            if (labels.includes('snip')) contentType = 'snips';
            else if (labels.includes('playlist')) contentType = 'playlists';
            else if (labels.includes('album')) contentType = 'albums';
            
            if (!contentType) {
              console.log('No valid content type label found');
              return;
            }
            
            // Create slug from title
            const slug = title.toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-')
              .replace(/-+/g, '-')
              .trim();
            
                         // Create frontmatter
             const now = new Date().toISOString();
             let frontmatter = `---\ntitle: "${title}"\npubDatetime: ${now}\nfeatured: false\ndraft: false\ntags: []\n`;

             // Add content-specific fields
             if (contentType === 'snips') {
               frontmatter += `description: "${title}"\nsource: "GitHub Issue"\nsourceUrl: "${issue.html_url}"\n`;
             } else if (contentType === 'playlists') {
               frontmatter += `description: "${body.split('\n')[0] || title}"\nplatform: "spotify"\nplaylistUrl: ""\nplaylistId: ""\nmood: []\n`;
                          } else if (contentType === 'albums') {
               frontmatter += `description: "${body.split('\n')[0] || title}"\nalbumArt: ""\n`;
             }
             
             frontmatter += `---\n\n${body}\n`;

             // Create file path
             const fileName = `${slug}.md`;
             let filePath;
             
             if (contentType === 'albums') {
               // For albums, create a directory and handle image attachments
               const albumDir = `src/content/photos/${slug}`;
               filePath = `${albumDir}/${fileName}`;
               
               // Create album directory
               await fs.promises.mkdir(albumDir, {recursive: true});
               
               // Process any image attachments from the issue
               const imageRegex = /!\[.*?\]\((https:\/\/github\.com\/.*?\/assets\/.*?)\)/g;
               const imageMatches = [...body.matchAll(imageRegex)];
               
               if (imageMatches.length > 0) {
                 console.log(`Found ${imageMatches.length} image(s) in issue`);
                 
                 for (let i = 0; i < imageMatches.length; i++) {
                   const imageUrl = imageMatches[i][1];
                   const imageExt = imageUrl.split('.').pop() || 'jpg';
                   const imageName = `${slug}-${i + 1}.${imageExt}`;
                   const imagePath = `${albumDir}/${imageName}`;
                   
                   try {
                     // Download the image
                     const imageResponse = await fetch(imageUrl);
                     if (imageResponse.ok) {
                       const imageBuffer = await imageResponse.arrayBuffer();
                       await fs.promises.writeFile(imagePath, Buffer.from(imageBuffer));
                       
                       // Create a markdown file for this photo
                       const photoFrontmatter = `---\nalbumId: "${slug}"\ntitle: "${title} - Photo ${i + 1}"\nphoto: "./${imageName}"\ncaption: ""\norder: ${i + 1}\npubDatetime: ${now}\n---\n\n`;
                       const photoMarkdownPath = `${albumDir}/${slug}-${i + 1}.md`;
                       await fs.promises.writeFile(photoMarkdownPath, photoFrontmatter);
                       
                       console.log(`Downloaded and created photo: ${imageName}`);
                     }
                   } catch (error) {
                     console.error(`Failed to download image ${imageUrl}:`, error);
                   }
                 }
               }
             } else {
               // For other content types, use standard path
               filePath = `src/content/${contentType}/${fileName}`;
               await fs.promises.mkdir(path.dirname(filePath), {recursive: true});
             }
             
             // Write the main content file
             await fs.promises.writeFile(filePath, frontmatter);
            
                         // Commit files
             const { execSync } = require('child_process');
             execSync('git config user.name "GitHub Action"');
             execSync('git config user.email "action@github.com"');
             
             if (contentType === 'albums') {
               // For albums, add the entire directory
               execSync(`git add "src/content/photos/${slug}/"`);
               execSync(`git commit -m "Add album: ${title} with photos (from issue #${issue.number})"`);
             } else {
               // For other content, add the single file
               execSync(`git add "${filePath}"`);
               execSync(`git commit -m "Add ${contentType.slice(0, -1)}: ${title} (from issue #${issue.number})"`);
             }
             
             execSync('git push');
            
            // Close the issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed'
            });
            
            // Add comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `âœ… Created ${contentType.slice(0, -1)}: \`${filePath}\``
            }); 